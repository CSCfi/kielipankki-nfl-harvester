"""
Zip-merging utilities for making publishable packages of NLF data.
"""

import sys
import pathlib
import tarfile
from zipfile import ZipFile, ZIP_DEFLATED, ZIP_STORED
import logging

logging.basicConfig(format="")


def update_zip_with_tar(zip_fileobj, tar_filepath, args):
    with tarfile.open(tar_filepath) as tar:
        for tar_item in tar:
            if not tar_item.isfile():
                # paths should be autogenerated in the zip
                continue
            if tar_item.name in args.paths_archived:
                logging.warning(
                    f"Path {z_info.filename} seen multiple times, only using first one"
                )
                continue
            with tar.extractfile(tar_item) as iobuf:
                args.paths_archived.add(tar_item.name)
                if pathlib.Path(tar_item.name).suffix in args.no_compress:
                    zip_fileobj.writestr(
                        tar_item.name,
                        iobuf.read(),
                        compress_type=ZIP_STORED,
                    )
                else:
                    zip_fileobj.writestr(tar_item.name, iobuf.read())


def update_zip_with_zip(target_zip_fileobj, source_zip_filepath, args):
    with ZipFile(source_zip_filepath) as z_obj:
        for z_info in z_obj.infolist():
            if z_info.is_dir():
                continue
            if z_info.filename in args.paths_archived:
                logging.info(f"Existing path {z_info.filename} overwritten by source")
                continue
            with z_obj.open(z_info) as z_fobj:
                args.paths_archived.add(z_info.filename)
                if pathlib.Path(z_info.filename).suffix in args.no_compress:
                    target_zip_fileobj.writestr(
                        z_info.filename,
                        z_fobj.read(),
                        compress_type=ZIP_STORED,
                    )
                else:
                    target_zip_fileobj.writestr(z_info.filename, z_fobj.read())


def update_zip_with_targets(args):
    """
    Create or update the zip in args.zipfilename with each target from args.sourcepaths.

    Targets are archives of some kind, and the paths within the targets will be used for
    storing the files in the zip. The only target file type currently supported is tar.
    In the future, other archives, like zips, should also be processed for contents.

    Files having an extension in args.no_compress will be stored without compression.
    """
    mv_target = None
    if args.zipfilename.exists():
        # If we're updating an actually existing zip, create a new one from scratch
        # and move to replace at the end
        mv_target = args.zipfilename
        args.zipfilename = args.zipfilename.with_name(args.zipfilename.name + ".tmp")
    with ZipFile(args.zipfilename, mode="a", compression=ZIP_DEFLATED) as zipfile:
        for sourcepath in args.sourcepaths:
            if sourcepath.suffix == ".tar":
                update_zip_with_tar(zipfile, sourcepath, args)
            elif sourcepath.suffix == ".zip":
                update_zip_with_zip(zipfile, sourcepath, args)
            else:
                print(
                    f"Warning: tried to update zip with unknown format {sourcepath}",
                    sys.stderr,
                )
        if mv_target:
            update_zip_with_zip(args.zipfilename, mv_target, args)
    if mv_target:
        args.zipfilename.rename(mv_target)


if __name__ == "__main__":
    import argparse

    argparser = argparse.ArgumentParser(
        prog="collect-to-zip",
        epilog="Optionally write additional source filenames to stdin",
    )
    argparser.add_argument("zipfilename", type=pathlib.Path, help="The target zip")
    argparser.add_argument(
        "--dir", type=pathlib.Path, help="Scan directory for sources"
    )
    argparser.add_argument(
        "--sourcelist", type=str, help="Read file for sources, or - for stdin"
    )
    argparser.add_argument("--verbose", action="store_true")
    argparser.add_argument(
        "--no-compress",
        "-n",
        help="A colon-separated list of suffixes to not compress, as in zip",
        default=".jpg:.jpeg:.jp2",
    )
    args = argparser.parse_args()
    args.paths_archived = set()
    args.sourcepaths = []
    if args.sourcelist:
        if args.sourcelist == "-":
            while True:
                try:
                    args.sourcepaths.append(pathlib.Path(input().strip()))
                except EOFError:
                    break
        else:
            args.sourcepaths += [
                pathlib.Path(line.strip()) for line in open(args.sourcelist)
            ]
    if args.dir:
        args.sourcepaths += [path for path in args.dir.iterdir() if path.is_file()]

    args.no_compress = set(args.no_compress.split(":"))

    if args.verbose:
        print(f"Updating {args.zipfilename} with:", file=sys.stderr)
        for source in args.sourcepaths:
            print(f"  {source}", file=sys.stderr)

    update_zip_with_targets(args)
